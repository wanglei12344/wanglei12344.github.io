{"meta":{"title":"小王的博客","subtitle":"","description":"Java,学习笔记","author":"wangxiaolei","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"JVM学习笔记(一)  自动内存管理","date":"2020-08-17T11:12:50.808Z","updated":"2020-08-17T11:36:41.237Z","comments":true,"path":"2020/08/17/JVM学习笔记(一)  自动内存管理/","link":"","permalink":"http://yoursite.com/2020/08/17/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%20%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"Java内存区域与内存溢出异常运行时数据区域 程序计数器线程私有。多线程环境下，恢复现场需要程序计数器。 如果执行的是一个Java方法，计数器记录的时正在执行的虚拟机字节码指令的地址。 如果执行的是一个Native方法，计数器值为空(Undefined)。 唯一一个没有OutOfMemoryError情况的区域。 Java虚拟机栈线程私有。 每个方法执行的时候，都会创建一个栈帧。 栈帧会存放局部变量表、动态连接、操作数栈、方法出口等信息。 局部变量表存放基本数据类型、对象引用（reference类型，不是对象本身）、returnAddress类型（指向一条字节码指定的地址）。存储空间用局部变量槽（slot）表示，long和double占用两个变量槽，其他的只占一个。 变量槽的大小由不同具体的虚拟机决定。 局部变量表所需要的内存空间在编译期间完成分配，方法运行期间大小不变。 一个方法的开始到结束对应着一个栈帧的入栈和出栈。 可能出现的异常状况： 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常 如果虚拟机栈容量可以扩展，当栈扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常 HotSpot虚拟机的栈容量不可以动态扩展，如果申请栈空间失败，还是会出现OutOfMemoryError异常 本地方法栈和Java虚拟机栈作用相似，只是为本地方法服务。 HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。 可能出现的异常情况和Java虚拟机栈相同。 Java堆所有线程共享，虚拟机启动时创建。 唯一目的：存放对象实例。 几乎所有的对象实例和数组都在堆上分配。 Java堆中可以划分出多个线程私有的分配缓冲区。 堆可以处于物理上不连续，但是逻辑上连续的内存空间中。 主流Java虚拟机的堆的大小都是可以扩展的。 异常情况：如果没有足够的内存分配给实例，并且堆也无法再扩展的时候，抛出OutOfMemoryError。 方法区所有线程共享。 存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据。 它时堆的一个逻辑部分，为了与堆区别开来，也称它为“非堆”（Non-Heap）。 JDK 8之后使用元空间实现方法区。 可以不实现垃圾回收。 内存回收的主要目标是对常量池的回收和对类型的卸载。 异常情况：如果方法区无法满足新的内存分配需求时，抛出OutOfMemoryError异常。 运行时常量池方法区的一部分。 Class文件中的常量池表（存放编译期生成的字面量和符号引用）将在类加载后存放到方法区的运行时常量池中。 符号引用翻译出来的直接引用也会存储在运行时常量池中。 HotSpot虚拟机对象探秘对象的创建当遇到一条字节码new指令的时候： 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。如果没有，则先执行类加载过程。 检查通过后，虚拟机将为新生对象分配内存。将一块确定大小的内存块从Java堆中划分出来。如果堆的内存是绝对规整的，使用“指针碰撞”进行内存分配；否则使用“空闲列表”进行内存分配。Java堆是否规整是由垃圾收集器是否带有空间压缩整理的能力决定的。 将分配到的内存空间（不包括对象头）初始化为零。 设置对象头信息。如对象是哪个类的实例、对象的GC分代年龄等。 调用构造函数，执行Class文件中new指令后的&lt;init&gt;() 方法，对象创建完成。 解决指针修改的并发问题： CAS + 失败重试 使用本地线程分配缓冲区分配内存 对象的内存布局对象在堆内存中的存储布局划分为三个部分：对象头、实例数据、对齐填充。 对象头包括： 运行时数据：包括哈希码、GC分代年龄、锁状态标志、线程持有的锁等。 类型指针：对象指向它的类型元数据的指针。用这个来判断对象是哪个类的实例。 如果对象是一个数组，对象头中还要存储数组长度。 实例数据： 程序代码中所定义的各种类型的字段内容。 对齐填充： 起到占位符的作业，不是必须存在的。 所有对象的大小都必须是8字节的整数倍，因为HotSpot虚拟机要求对象起始地址必须是8字节的整数倍。 对象头部分是8字节的整数倍，如果实例数据部分不是8字节的整数倍就需要对齐填充。 对象的访问定位两种方式： 句柄访问： 直接指针： 区别： 直接指针比句柄访问的方式少了一次间接访问的开销。 在对象被移动的时候，句柄访问方式不用修改reference本身。 两种方式都比较常见，HotSpot主要使用直接指针的方式。 实战：OutOfMemoryError异常设置虚拟机参数 Java堆溢出-Xms20m：堆的最小大小为20m -Xmx20m：堆的最大大小为20m -XX：保存当前内存堆转储快照 内存泄露和内存溢出内存溢出：程序在申请内存时，没有足够的内存空间供其使用 内存泄漏：程序在申请内存后，无法释放已申请的内存空间 内存溢出最终会导致内存泄漏 虚拟机栈和本地方法栈溢出HotSpot虚拟机不区分虚拟机栈和本地方法栈。 -Xss128k：栈容量128k 不加参数运行时，栈深度为25260 加参数后，栈深度为 这段代码使用递归来创建栈帧，当栈无法容纳新的栈帧的时候，就抛出StackOverFlowError异常。 当局部变量表过大导致栈帧过大时，也会出现StackOverFlowError异常 方法区和运行时常量池溢出String::intern() 是一个本地方法，如果字符串常量池中没有包含该字符串，则将字符串添加到常量池并返回字符串对象的引用，否则直接返回字符串对象的引用。 JDK 8之后永生代被元空间替代，很难出现方法区的溢出异常。 -XX:MaxMetaspaceSize：设置元空间最大值，默认-1不限制。 -XX:MetaspaceSize：指定元空间的初始空间大小。 -XX:MinMetaspaceFreeRatio：垃圾收集之后控制最小的元空间剩余容量的百分比。 -XX:MaxMetaspaceFreeRatio：垃圾收集之后控制最大的元空间剩余容量的百分比。 本机直接内存溢出-XX:MaxDirectMemorySize：设置直接内存的容量大小","categories":[],"tags":[]}],"categories":[],"tags":[]}